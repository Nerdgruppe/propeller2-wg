from dataclasses import dataclass, field as ds_field
from pathlib import Path
from enum import Enum
import io
import logging
import json
import sys
from typing import ClassVar, Iterable
import yaml

from common import (
    decode_json,
    Flag,
    OpType,
    BitField,
    OP_DISPLAY_TEXT,
    OP_MAPPING,
    P2INSTRUCTIONS_JSON,
)


def newslot(slot):
    return f".init({slot.offset}, {slot.length})"


OP_ZIG_TYPE: dict[OpType, str] = {
    OpType.ADDRESS: ".{{ .address = .{{ .rel = {rel} }} }}",
    OpType.AUGMENT: ".{{ .immediate = 9 }}",
    OpType.C_REMAP: ".{{ .enumeration = modcz_items }}",
    OpType.DEST_EITHER: ".{{ .reg_or_imm = .{{ .imm = {imm}, .pcrel = false }} }}",
    OpType.DEST_REG: ".register",
    OpType.PREG: ".pointer_reg",
    OpType.PTREXPR: ".{{ .pointer_expr = .{{ .imm = {imm} }} }}",
    OpType.SELECTOR: ".{{ .immediate = 0 }}",
    OpType.SRC_EITHER: ".{{ .reg_or_imm = .{{ .imm = {imm}, .pcrel = false }} }}",
    OpType.SRC_EITHER_PCREL: ".{{ .reg_or_imm = .{{ .imm = {imm}, .pcrel = true }} }}",
    OpType.Z_REMAP: ".{{ .enumeration = modcz_items }}",
}

FLAG_ZIG_FIELD: dict[Flag, str] = {
    Flag.NONE: "none",
    Flag.WC: "wc",
    Flag.WZ: "wz",
    Flag.WCZ: "wcz",
    Flag.ANDC: "and_c",
    Flag.ANDZ: "and_z",
    Flag.ORC: "or_c",
    Flag.ORZ: "or_z",
    Flag.XORC: "xor_c",
    Flag.XORZ: "xor_z",
}


def render_zig(stream: io.IOBase, instructions: list[Instruction]) -> None:
    stream.write("//!\n")
    stream.write(
        "//! This file was auto-generated by <repo>/utility/gen_propan_instructions.zig.py\n"
    )
    stream.write("//!\n")

    stream.write("\n")
    stream.write('const sema = @import("../../sema.zig");\n')
    stream.write("\n")
    stream.write('const modcz_items = @import("constants.zig").modcz_items;\n')
    stream.write("\n")

    stream.write("pub const p2_instructions: []const sema.EncodedInstruction = &.{\n")

    for instr in instructions:
        stream.write(f"    // {instr.display_text}\n")
        stream.write(f"    // {instr.encoding}\n")
        stream.write("    .{\n")

        stream.write(f'        .mnemonic = "{instr.name}",\n')
        stream.write(f"        .binary = 0x{instr.encoding.binary:0>8x},\n")
        stream.write("        .effects = .from_list(&.{ ")

        for i, flag in enumerate(sorted(instr.flags)):
            if i > 0:
                stream.write(", ")
            stream.write(f".{FLAG_ZIG_FIELD[flag]}")

        stream.write(" }),\n")
        stream.write("        .operands = &.{\n")
        for op in instr.operands:
            mapping = OP_MAPPING[op]

            zig_op_type = OP_ZIG_TYPE[op]

            op_slot = instr.encoding.fields[mapping.field]

            type_fmt_slots: dict[str, str] = {}
            if mapping.imm is not None:
                type_fmt_slots["imm"] = newslot(instr.encoding.fields[mapping.imm])
            if mapping.rel is not None:
                type_fmt_slots["rel"] = newslot(instr.encoding.fields[mapping.rel])

            zig_op_type = zig_op_type.format(**type_fmt_slots)

            stream.write(f"            .{{ // {OP_DISPLAY_TEXT[op]}\n")
            stream.write(f"                .slot = {newslot(op_slot)},\n")
            stream.write(f"                .type = {zig_op_type},\n")
            stream.write("            },\n")
        stream.write("        },\n")

        c_effect_slot = instr.encoding.fields.get(BitField.WRITE_C)
        if c_effect_slot is not None:
            stream.write(f"        .c_effect_slot = {newslot(c_effect_slot)},\n")

        z_effect_slot = instr.encoding.fields.get(BitField.WRITE_Z)
        if z_effect_slot is not None:
            stream.write(f"        .z_effect_slot = {newslot(z_effect_slot)},\n")

        stream.write("    },\n")

    stream.write("};\n")


def main() -> int | None:
    instructions = decode_json(P2INSTRUCTIONS_JSON)

    logging.info("loaded %d instructions!", len(instructions))

    render_zig(sys.stdout, instructions)


if __name__ == "__main__":
    sys.exit(main() or 0)


# Predefined Instruction Groups:
#   "EEEE _____WW RAA AAAAAAAAA AAAAAAAAA"
#   "EEEE ______N NNI DDDDDDDDD SSSSSSSSS"
#   "EEEE _______ CLI DDDDDDDDD SSSSSSSSS"
#   "EEEE _______ CZI DDDDDDDDD SSSSSSSSS"
#   "EEEE _______ CZL DDDDDDDDD _________"
#   "EEEE _______ CZ_ DDDDDDDDD _________"
#   "EEEE _______ CZ_ _________ _________"
#   "EEEE _______ CZ_ _cccczzzz _________"
#   "EEEE _______ C_I DDDDDDDDD SSSSSSSSS"
#   "EEEE _______ C_L DDDDDDDDD _________"
#   "EEEE _______ C__ DDDDDDDDD _________"
#   "EEEE _______ C__ _cccc____ _________"
#   "EEEE _______ NNI DDDDDDDDD SSSSSSSSS"
#   "EEEE _______ RAA AAAAAAAAA AAAAAAAAA"
#   "EEEE _______ _LI DDDDDDDDD SSSSSSSSS"
#   "EEEE _______ _L_ DDDDDDDDD _________"
#   "EEEE _______ _NI DDDDDDDDD SSSSSSSSS"
#   "EEEE _______ _ZI DDDDDDDDD SSSSSSSSS"
#   "EEEE _______ _Z_ _____zzzz _________"
#   "EEEE _______ __I DDDDDDDDD SSSSSSSSS"
#   "EEEE _______ __I _________ SSSSSSSSS"
#   "EEEE _______ __L DDDDDDDDD _________"
#   "EEEE _______ ___ DDDDDDDDD _________"
#   "EEEE _______ ___ _________ _________"
#   "EEEE _____nn nnn nnnnnnnnn nnnnnnnnn"
#   "____ _______ ___ _________ _________"
